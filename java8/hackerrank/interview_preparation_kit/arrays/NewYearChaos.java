/**
 *
 * https://www.hackerrank.com/challenges/new-year-chaos/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays
 */
import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.*;

public class Solution {

    // Complete the minimumBribes function below.
    // O(n^2) solution
    // static void minimumBribes(int[] q) {
    //     int n = q.length;
    //     int bribes = 0;
    //     boolean chaotic = false;

    //     for (int i = 0; i < n; i++) {
    //         int b = 0;
    //         for (int j = i+1; j < n; j++) {
    //             if (q[j] < q[i]) {
    //                 b++;
    //             }
    //         }
    //         if (b > 2) {
    //             chaotic = true;
    //             break;
    //         }
    //         bribes += b;
    //     }

    //     if (chaotic) {
    //         System.out.println("Too chaotic");
    //     } else {
    //         System.out.println(bribes);
    //     }
    // }

    // O(nlogn) solution
    // Counting the inversions
    static void minimumBribes(int[] q) {
        // check whether chaotic first
        boolean chaotic = false;
        for (int i = 0; i < q.length; i++) {
            if (q[i] - (i+1) > 2) {
                chaotic = true;
                break;
            }
        }

        if (chaotic) {
            System.out.println("Too chaotic");
        } else {
            // count inversions and print it
            System.out.println(mergeSort(q));
        }
    }


    static int mergeSort(int[] arr) {
        return mergeSort(arr, new int[arr.length], 0, arr.length - 1);
    }

    static int mergeSort(int[] arr, int[] temp, int left, int right) {
        int inversions = 0;
        if (right > left) {
            int mid = left + (right - left) / 2;
            inversions += mergeSort(arr, temp, left, mid);
            inversions += mergeSort(arr, temp, mid+1, right);
            inversions += merge(arr, temp, left, mid, right);
        }
        return inversions;
    }

    static int merge(int[] arr, int[] temp, int left, int mid, int right) {
        int i = left;
        int j = mid + 1;
        int k = left;

        int inversions = 0;
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
                // i, i+1, i+2, ... mid inverse with j
                inversions += mid - i + 1;
            }
        }

        while (i <= mid) {
            temp[k++] = arr[i++];
        }

        while (j <= right) {
            temp[k++] = arr[j++];
        }

        for (int x = left; x <= right; x++) {
            arr[x] = temp[x];
        }

        return inversions;
    }

    /**
     *
     * Stub code for I/O operations generated by hackerrank editor
     */

    private static final Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        int t = scanner.nextInt();
        scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

        for (int tItr = 0; tItr < t; tItr++) {
            int n = scanner.nextInt();
            scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

            int[] q = new int[n];

            String[] qItems = scanner.nextLine().split(" ");
            scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

            for (int i = 0; i < n; i++) {
                int qItem = Integer.parseInt(qItems[i]);
                q[i] = qItem;
            }

            minimumBribes(q);
        }

        scanner.close();
    }
}
